#include "Text.h"

Text::Text() : font(std::unique_ptr<TTF_Font, InvokeDestroy>(TTF_OpenFont("PressStart2P-Regular.ttf", 16))) {}

/*  the createAtlas function will create one single texture we can then use to render any future text.  because this program intends to have text
*   displays that change often (the swap counter) it is more efficient to create this glyph atlas texture and render from that.
*   otherwise we would have to create a surface and texture for every single text update, and often that texture would only be needed for a few
*   frames at most.  instead of doing those expensive operations many times, we'll use this much more efficient method.   */
void Text::createAtlas(SDL_Renderer* renderer)
{
	constexpr int nullTerminatedChar = 2, textureSize = 512, depth = 32, alphaMask = 255;
	constexpr SDL_Color white = { 255, 255, 255, 255 }, black = { 0, 0, 0 ,0 };
	SDL_Rect destRect = { 0, 0, 0, 0 };
	SDL_Surface* s = SDL_CreateRGBSurface(0, textureSize, textureSize, depth, black.r, black.g, black.b, alphaMask);
	std::unique_ptr<SDL_Surface, InvokeDestroy> surface;
	std::unique_ptr<SDL_Surface, InvokeDestroy> text;
	surface.reset(s);  // make the unique_ptr the owner of the pointer

	SDL_SetColorKey(surface.get(), SDL_TRUE, SDL_MapRGBA(surface->format, black.r, black.g, black.b, black.a));  // set the background of the text surface to be transparent

	for (int i = ' '; i < 'z'; ++i)
	{
		/* some of the functions we will be using require a const char* parameter, which specifically has to be null terminated.
		*  to faciliate this we can use this small array, and creating it like this makes it so it is implicitly null terminated.  */
		char cc[nullTerminatedChar] = { static_cast<char>(i) };
		text = std::unique_ptr<SDL_Surface, InvokeDestroy>(TTF_RenderUTF8_Blended(font.get(), cc, white));

		// get the size of the character we just rendered and set destRect's width and height accordingly
		TTF_SizeText(font.get(), cc, &destRect.w, &destRect.h);

		if (destRect.x + destRect.y >= textureSize)
		{
			destRect.x = 0;
			destRect.y += destRect.h + 1;
		}
		
		SDL_BlitSurface(text.get(), nullptr, surface.get(), &destRect);  // copy the text surface onto the surface we will use for the full texture

		glyphRects[i] = { destRect.x, destRect.y, destRect.w, destRect.h };
		destRect.x += destRect.w;
	}

	atlasTexture = std::unique_ptr<SDL_Texture, InvokeDestroy>(SDL_CreateTextureFromSurface(renderer, surface.get())); // create the full atlas texture
}

void Text::render(SDL_Renderer* renderer, const std::string& textToRender, const SDL_Color& textColor, SDL_Rect displayLocation) const
{
	SDL_SetTextureColorMod(atlasTexture.get(), textColor.r, textColor.g, textColor.b);

	for (const char& c : textToRender)
	{
		displayLocation.w = glyphRects.at(static_cast<int>(c)).w;
		displayLocation.h = glyphRects.at(static_cast<int>(c)).h;
		SDL_RenderCopy(renderer, atlasTexture.get(), &glyphRects.at(static_cast<int>(c)), &displayLocation);
		displayLocation.x += glyphRects.at(static_cast<int>(c)).w;
	}
}